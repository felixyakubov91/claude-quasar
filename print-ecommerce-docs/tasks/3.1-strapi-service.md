# Task 3.1: Strapi Service

## Goal
Create a TypeScript service for fetching data from Strapi API.

## Prerequisites
- Phase 2 completed
- Strapi running with data

## Instructions

### Step 1: Install Axios

```bash
cd frontend
npm install axios
```

### Step 2: Create Strapi Service

Create `frontend/src/services/strapi.service.ts`:

```typescript
import axios, { AxiosInstance } from 'axios';
import { env } from 'src/utils/env';

class StrapiService {
  private client: AxiosInstance;

  constructor() {
    this.client = axios.create({
      baseURL: `${env.strapiUrl}/api`,
      headers: {
        'Content-Type': 'application/json',
        Authorization: env.strapiApiToken ? `Bearer ${env.strapiApiToken}` : undefined,
      },
    });
  }

  // Products
  async getProducts(params: {
    page?: number;
    pageSize?: number;
    category?: string;
    minPrice?: number;
    maxPrice?: number;
    sort?: string;
    featured?: boolean;
  } = {}) {
    const filters: any = { is_active: { $eq: true } };

    if (params.category) {
      filters.category = { slug: { $eq: params.category } };
    }
    if (params.minPrice !== undefined) {
      filters.base_price = { ...filters.base_price, $gte: params.minPrice };
    }
    if (params.maxPrice !== undefined) {
      filters.base_price = { ...filters.base_price, $lte: params.maxPrice };
    }
    if (params.featured) {
      filters.is_featured = { $eq: true };
    }

    const response = await this.client.get('/products', {
      params: {
        filters,
        sort: params.sort || 'sort_order:asc',
        pagination: {
          page: params.page || 1,
          pageSize: params.pageSize || 12,
        },
        populate: ['thumbnail', 'category', 'images'],
      },
    });

    return response.data;
  }

  async getProductBySlug(slug: string) {
    const response = await this.client.get('/products', {
      params: {
        filters: { slug: { $eq: slug } },
        populate: ['images', 'category', 'options', 'pricing_tiers', 'reviews.customer'],
      },
    });

    return response.data.data?.[0] || null;
  }

  // Categories
  async getCategories(params: { parent?: string; active?: boolean } = {}) {
    const filters: any = {};

    if (params.active !== false) {
      filters.is_active = { $eq: true };
    }
    if (params.parent) {
      filters.parent = { slug: { $eq: params.parent } };
    } else if (params.parent === null) {
      filters.parent = { $null: true };
    }

    const response = await this.client.get('/categories', {
      params: {
        filters,
        sort: 'sort_order:asc',
        populate: ['image', 'parent'],
      },
    });

    return response.data;
  }

  async getCategoryBySlug(slug: string) {
    const response = await this.client.get('/categories', {
      params: {
        filters: { slug: { $eq: slug } },
        populate: ['image', 'parent', 'products'],
      },
    });

    return response.data.data?.[0] || null;
  }

  // Orders (requires auth)
  async createOrder(data: any, token: string) {
    const response = await this.client.post('/orders', { data }, {
      headers: { Authorization: `Bearer ${token}` },
    });
    return response.data;
  }

  async getOrders(token: string) {
    const response = await this.client.get('/orders', {
      headers: { Authorization: `Bearer ${token}` },
      params: {
        sort: 'createdAt:desc',
        populate: ['items.product', 'items.uploaded_images'],
      },
    });
    return response.data;
  }

  // Cart
  async saveCart(customerId: string, items: any[], token: string) {
    // Find existing cart
    const existing = await this.client.get('/carts', {
      headers: { Authorization: `Bearer ${token}` },
      params: { filters: { customer: { id: { $eq: customerId } } } },
    });

    if (existing.data.data?.length > 0) {
      // Update existing
      await this.client.put(`/carts/${existing.data.data[0].id}`, {
        data: { items, updated_at: new Date() },
      }, {
        headers: { Authorization: `Bearer ${token}` },
      });
    } else {
      // Create new
      await this.client.post('/carts', {
        data: { customer: customerId, items, updated_at: new Date() },
      }, {
        headers: { Authorization: `Bearer ${token}` },
      });
    }
  }

  // Coupons
  async validateCoupon(code: string) {
    const response = await this.client.get('/coupons', {
      params: {
        filters: {
          code: { $eq: code.toUpperCase() },
          is_active: { $eq: true },
          valid_from: { $lte: new Date().toISOString() },
          $or: [
            { valid_until: { $null: true } },
            { valid_until: { $gte: new Date().toISOString() } },
          ],
        },
      },
    });

    return response.data.data?.[0] || null;
  }

  // Reviews
  async createReview(data: any, token: string) {
    const response = await this.client.post('/reviews', { data }, {
      headers: { Authorization: `Bearer ${token}` },
    });
    return response.data;
  }

  // Shipping zones
  async getShippingZones() {
    const response = await this.client.get('/shipping-zones', {
      params: { filters: { is_active: { $eq: true } } },
    });
    return response.data;
  }

  // Homepage
  async getHomepage() {
    const response = await this.client.get('/homepage', {
      params: {
        populate: [
          'hero_slides.image',
          'featured_products.thumbnail',
          'featured_categories.image',
          'promotional_blocks.image',
          'testimonials.avatar',
          'seo.og_image',
        ],
      },
    });
    return response.data;
  }
}

export const strapiService = new StrapiService();
```

### Step 3: Create Boot File

Create `frontend/src/boot/strapi.ts`:

```typescript
import { boot } from 'quasar/wrappers';
import { strapiService } from 'src/services/strapi.service';

export default boot(({ app }) => {
  app.config.globalProperties.$strapi = strapiService;
});

export { strapiService };
```

## Acceptance Criteria
- [ ] Products fetch with filtering
- [ ] Categories fetch with hierarchy
- [ ] Coupon validation works
- [ ] Auth-protected endpoints use token
