# Task 3.2: Product Listing

## Goal
Build product listing pages with filtering, sorting, and pagination.

## Prerequisites
- Task 3.1 completed

## Instructions

### Step 1: Create Products Page

Create `frontend/src/pages/products/IndexPage.vue`:

```vue
<template>
  <q-page class="q-pa-md">
    <!-- Breadcrumbs -->
    <q-breadcrumbs class="q-mb-md">
      <q-breadcrumbs-el :label="$t('nav.home')" to="/" />
      <q-breadcrumbs-el :label="$t('nav.allProducts')" />
    </q-breadcrumbs>

    <div class="row q-col-gutter-lg">
      <!-- Filters Sidebar -->
      <div class="col-12 col-md-3">
        <ProductFilters
          v-model:category="filters.category"
          v-model:min-price="filters.minPrice"
          v-model:max-price="filters.maxPrice"
          :categories="categories"
          @update="fetchProducts"
        />
      </div>

      <!-- Products Grid -->
      <div class="col-12 col-md-9">
        <!-- Toolbar -->
        <div class="row items-center justify-between q-mb-md">
          <div class="col-auto">
            <span class="text-grey-7">
              {{ $t('products.showing', { count: pagination.total }) }}
            </span>
          </div>
          <div class="col-auto">
            <q-select
              v-model="sort"
              :options="sortOptions"
              :label="$t('products.sortBy')"
              dense
              outlined
              emit-value
              map-options
              style="min-width: 200px"
              @update:model-value="fetchProducts"
            />
          </div>
        </div>

        <!-- Loading -->
        <div v-if="loading" class="row q-col-gutter-md">
          <div v-for="n in 8" :key="n" class="col-6 col-md-4 col-lg-3">
            <q-skeleton height="300px" />
          </div>
        </div>

        <!-- Products -->
        <ProductGrid v-else :products="products" />

        <!-- Pagination -->
        <div class="flex flex-center q-mt-lg">
          <q-pagination
            v-model="pagination.page"
            :max="pagination.pageCount"
            :max-pages="7"
            direction-links
            boundary-links
            @update:model-value="fetchProducts"
          />
        </div>
      </div>
    </div>
  </q-page>
</template>

<script setup lang="ts">
import { ref, reactive, onMounted } from 'vue';
import { useI18n } from 'vue-i18n';
import { strapiService } from 'src/services/strapi.service';
import ProductFilters from 'src/components/products/ProductFilters.vue';
import ProductGrid from 'src/components/products/ProductGrid.vue';

const { t } = useI18n();

const loading = ref(true);
const products = ref([]);
const categories = ref([]);

const filters = reactive({
  category: null,
  minPrice: null,
  maxPrice: null,
});

const sort = ref('sort_order:asc');
const sortOptions = [
  { label: t('products.sortNewest'), value: 'createdAt:desc' },
  { label: t('products.sortPriceLow'), value: 'base_price:asc' },
  { label: t('products.sortPriceHigh'), value: 'base_price:desc' },
  { label: t('products.sortName'), value: 'name_en:asc' },
];

const pagination = reactive({
  page: 1,
  pageSize: 12,
  total: 0,
  pageCount: 1,
});

const fetchProducts = async () => {
  loading.value = true;
  try {
    const response = await strapiService.getProducts({
      page: pagination.page,
      pageSize: pagination.pageSize,
      category: filters.category,
      minPrice: filters.minPrice,
      maxPrice: filters.maxPrice,
      sort: sort.value,
    });

    products.value = response.data;
    pagination.total = response.meta.pagination.total;
    pagination.pageCount = response.meta.pagination.pageCount;
  } finally {
    loading.value = false;
  }
};

const fetchCategories = async () => {
  const response = await strapiService.getCategories({ parent: null });
  categories.value = response.data;
};

onMounted(() => {
  fetchCategories();
  fetchProducts();
});
</script>
```

### Step 2: Create ProductFilters Component

Create `frontend/src/components/products/ProductFilters.vue`:

```vue
<template>
  <q-card flat bordered>
    <q-card-section>
      <div class="text-h6 q-mb-md">{{ $t('products.filters') }}</div>

      <!-- Categories -->
      <div class="q-mb-md">
        <div class="text-subtitle2 q-mb-sm">{{ $t('nav.categories') }}</div>
        <q-option-group
          :model-value="category"
          :options="categoryOptions"
          type="radio"
          @update:model-value="$emit('update:category', $event)"
        />
      </div>

      <q-separator class="q-my-md" />

      <!-- Price Range -->
      <div class="q-mb-md">
        <div class="text-subtitle2 q-mb-sm">{{ $t('products.priceRange') }}</div>
        <div class="row q-col-gutter-sm">
          <div class="col-6">
            <q-input
              :model-value="minPrice"
              type="number"
              :label="$t('products.min')"
              dense
              outlined
              @update:model-value="$emit('update:minPrice', $event)"
            />
          </div>
          <div class="col-6">
            <q-input
              :model-value="maxPrice"
              type="number"
              :label="$t('products.max')"
              dense
              outlined
              @update:model-value="$emit('update:maxPrice', $event)"
            />
          </div>
        </div>
      </div>

      <q-btn
        color="primary"
        :label="$t('products.applyFilters')"
        class="full-width"
        @click="$emit('update')"
      />

      <q-btn
        flat
        color="grey"
        :label="$t('products.clearFilters')"
        class="full-width q-mt-sm"
        @click="clearFilters"
      />
    </q-card-section>
  </q-card>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useI18n } from 'vue-i18n';
import { useRtl } from 'src/composables/useRtl';

const props = defineProps<{
  category: string | null;
  minPrice: number | null;
  maxPrice: number | null;
  categories: any[];
}>();

const emit = defineEmits(['update:category', 'update:minPrice', 'update:maxPrice', 'update']);

const { t } = useI18n();
const { isRtl } = useRtl();

const categoryOptions = computed(() => [
  { label: t('products.allCategories'), value: null },
  ...props.categories.map((cat) => ({
    label: isRtl.value ? cat.attributes.name_he : cat.attributes.name_en,
    value: cat.attributes.slug,
  })),
]);

const clearFilters = () => {
  emit('update:category', null);
  emit('update:minPrice', null);
  emit('update:maxPrice', null);
  emit('update');
};
</script>
```

### Step 3: Create ProductGrid Component

Create `frontend/src/components/products/ProductGrid.vue`:

```vue
<template>
  <div v-if="products.length > 0" class="row q-col-gutter-md">
    <div
      v-for="product in products"
      :key="product.id"
      class="col-6 col-md-4 col-lg-3"
    >
      <ProductCard :product="product" />
    </div>
  </div>

  <div v-else class="text-center q-pa-xl">
    <q-icon name="search_off" size="64px" color="grey-5" />
    <p class="text-h6 text-grey-7 q-mt-md">{{ $t('products.noProducts') }}</p>
  </div>
</template>

<script setup lang="ts">
import ProductCard from './ProductCard.vue';

defineProps<{
  products: any[];
}>();
</script>
```

### Step 4: Create ProductCard Component

Create `frontend/src/components/products/ProductCard.vue`:

```vue
<template>
  <q-card class="product-card cursor-pointer" @click="goToProduct">
    <q-img
      :src="thumbnailUrl"
      :ratio="1"
      class="product-image"
    >
      <template v-slot:loading>
        <q-skeleton square />
      </template>

      <!-- Sale Badge -->
      <div v-if="isOnSale" class="absolute-top-left q-pa-xs">
        <q-badge color="red" :label="$t('products.sale')" />
      </div>
    </q-img>

    <q-card-section>
      <!-- Category -->
      <div class="text-caption text-grey-6 q-mb-xs">
        {{ categoryName }}
      </div>

      <!-- Name -->
      <div class="text-subtitle1 ellipsis-2-lines" style="min-height: 48px">
        {{ productName }}
      </div>

      <!-- Price -->
      <div class="q-mt-sm">
        <span v-if="isOnSale" class="text-strike text-grey-6 q-mr-sm">
          {{ formatPrice(product.attributes.base_price) }}
        </span>
        <span class="text-h6 text-primary price-display">
          {{ formatPrice(currentPrice) }}
        </span>
      </div>
    </q-card-section>

    <q-card-actions>
      <q-btn
        color="primary"
        :label="$t('products.addToCart')"
        class="full-width"
        @click.stop="addToCart"
      />
    </q-card-actions>
  </q-card>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useRouter } from 'vue-router';
import { useRtl } from 'src/composables/useRtl';
import { useCartStore } from 'src/stores/cart.store';
import { env } from 'src/utils/env';

const props = defineProps<{
  product: any;
}>();

const router = useRouter();
const { isRtl } = useRtl();
const cartStore = useCartStore();

const productName = computed(() =>
  isRtl.value
    ? props.product.attributes.name_he || props.product.attributes.name_en
    : props.product.attributes.name_en
);

const categoryName = computed(() => {
  const cat = props.product.attributes.category?.data?.attributes;
  if (!cat) return '';
  return isRtl.value ? cat.name_he || cat.name_en : cat.name_en;
});

const thumbnailUrl = computed(() =>
  props.product.attributes.thumbnail?.data?.attributes?.url || '/placeholder.png'
);

const isOnSale = computed(() =>
  props.product.attributes.sale_price &&
  props.product.attributes.sale_price < props.product.attributes.base_price
);

const currentPrice = computed(() =>
  isOnSale.value
    ? props.product.attributes.sale_price
    : props.product.attributes.base_price
);

const formatPrice = (price: number) =>
  `${env.currencySymbol}${price.toFixed(2)}`;

const goToProduct = () => {
  router.push({
    name: 'product',
    params: { slug: props.product.attributes.slug },
  });
};

const addToCart = () => {
  cartStore.addItem(props.product, 1, {});
};
</script>

<style scoped lang="scss">
.product-card {
  transition: transform 0.2s, box-shadow 0.2s;

  &:hover {
    transform: translateY(-4px);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
  }
}

.ellipsis-2-lines {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}
</style>
```

## Acceptance Criteria
- [ ] Products display in grid
- [ ] Filtering by category works
- [ ] Price range filter works
- [ ] Sorting changes order
- [ ] Pagination loads more
- [ ] RTL layout correct
- [ ] All text uses translations
