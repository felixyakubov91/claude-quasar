# Task 6.3: Review System

## Goal
Implement product review system with ratings.

## Instructions

### Create ProductReviews Component
Create `frontend/src/components/products/ProductReviews.vue`:

```vue
<template>
  <div class="product-reviews">
    <div class="row items-center justify-between q-mb-md">
      <div class="text-h6">{{ $t('reviews.title') }}</div>
      <q-btn
        v-if="canReview"
        color="primary"
        outline
        :label="$t('reviews.writeReview')"
        @click="showReviewDialog = true"
      />
    </div>

    <div v-if="reviews.length" class="row q-col-gutter-md q-mb-lg">
      <div class="col-12 col-md-4">
        <q-card flat bordered class="text-center q-pa-md">
          <div class="text-h2">{{ averageRating.toFixed(1) }}</div>
          <q-rating
            :model-value="averageRating"
            readonly
            size="24px"
            color="warning"
            icon="star"
            icon-half="star_half"
          />
          <div class="text-grey-7 q-mt-sm">
            {{ $t('reviews.basedOn', { count: reviews.length }) }}
          </div>
        </q-card>
      </div>

      <div class="col-12 col-md-8">
        <RatingBreakdown :reviews="reviews" />
      </div>
    </div>

    <q-list separator v-if="reviews.length">
      <ReviewItem
        v-for="review in displayedReviews"
        :key="review.id"
        :review="review"
      />
    </q-list>

    <div v-else class="text-center q-pa-xl text-grey-6">
      <q-icon name="rate_review" size="64px" class="q-mb-md" />
      <p>{{ $t('reviews.noReviews') }}</p>
      <p class="text-body2">{{ $t('reviews.beFirst') }}</p>
    </div>

    <div v-if="reviews.length > 3" class="text-center q-mt-md">
      <q-btn
        flat
        color="primary"
        :label="showAllReviews ? $t('reviews.showLess') : $t('reviews.showAll')"
        @click="showAllReviews = !showAllReviews"
      />
    </div>

    <ReviewDialog
      v-model="showReviewDialog"
      :product-id="productId"
      @submitted="onReviewSubmitted"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';
import { useAuth } from 'src/composables/useAuth';
import { strapiService } from 'src/services/strapi.service';
import ReviewItem from './ReviewItem.vue';
import ReviewDialog from './ReviewDialog.vue';
import RatingBreakdown from './RatingBreakdown.vue';

const props = defineProps<{ productId: number }>();

const { isAuthenticated, user } = useAuth();

const reviews = ref<any[]>([]);
const loading = ref(false);
const showReviewDialog = ref(false);
const showAllReviews = ref(false);
const userHasPurchased = ref(false);
const userHasReviewed = ref(false);

const averageRating = computed(() => {
  if (!reviews.value.length) return 0;
  const sum = reviews.value.reduce((acc, r) => acc + r.attributes.rating, 0);
  return sum / reviews.value.length;
});

const canReview = computed(() => {
  return isAuthenticated.value && userHasPurchased.value && !userHasReviewed.value;
});

const displayedReviews = computed(() => {
  return showAllReviews.value ? reviews.value : reviews.value.slice(0, 3);
});

const loadReviews = async () => {
  loading.value = true;
  try {
    const response = await strapiService.getProductReviews(props.productId);
    reviews.value = response.data || [];

    if (user.value) {
      userHasReviewed.value = reviews.value.some(
        (r: any) => r.attributes.customer?.data?.attributes?.supabase_id === user.value?.id
      );
    }
  } finally {
    loading.value = false;
  }
};

const checkPurchaseHistory = async () => {
  if (!user.value) return;

  try {
    const response = await strapiService.checkUserPurchased(props.productId, user.value.id);
    userHasPurchased.value = response.purchased;
  } catch {
    userHasPurchased.value = false;
  }
};

const onReviewSubmitted = () => {
  showReviewDialog.value = false;
  loadReviews();
  userHasReviewed.value = true;
};

onMounted(() => {
  loadReviews();
  checkPurchaseHistory();
});
</script>
```

### Create ReviewItem Component
Create `frontend/src/components/products/ReviewItem.vue`:

```vue
<template>
  <q-item class="q-py-md">
    <q-item-section avatar top>
      <q-avatar color="primary" text-color="white">
        {{ initials }}
      </q-avatar>
    </q-item-section>

    <q-item-section>
      <q-item-label class="row items-center q-gutter-sm">
        <span class="text-weight-medium">{{ review.attributes.customer?.data?.attributes?.full_name || $t('reviews.anonymous') }}</span>
        <q-badge v-if="review.attributes.is_verified_purchase" color="positive" outline>
          {{ $t('reviews.verifiedPurchase') }}
        </q-badge>
      </q-item-label>

      <q-item-label class="row items-center q-mt-xs">
        <q-rating
          :model-value="review.attributes.rating"
          readonly
          size="16px"
          color="warning"
          icon="star"
        />
        <span class="text-grey-7 q-ml-sm text-caption">
          {{ formatDate(review.attributes.createdAt) }}
        </span>
      </q-item-label>

      <q-item-label v-if="review.attributes.title" class="text-weight-medium q-mt-sm">
        {{ review.attributes.title }}
      </q-item-label>

      <q-item-label class="q-mt-sm text-body2">
        {{ review.attributes.content }}
      </q-item-label>
    </q-item-section>
  </q-item>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useI18n } from 'vue-i18n';
import { format } from 'date-fns';
import { he, enUS } from 'date-fns/locale';

const props = defineProps<{ review: any }>();
const { locale } = useI18n();

const initials = computed(() => {
  const name = props.review.attributes.customer?.data?.attributes?.full_name || 'A';
  return name.charAt(0).toUpperCase();
});

const formatDate = (dateString: string) => {
  const date = new Date(dateString);
  return format(date, 'dd MMM yyyy', {
    locale: locale.value === 'he' ? he : enUS,
  });
};
</script>
```

### Create ReviewDialog Component
Create `frontend/src/components/products/ReviewDialog.vue`:

```vue
<template>
  <q-dialog :model-value="modelValue" @update:model-value="$emit('update:modelValue', $event)">
    <q-card style="min-width: 400px; max-width: 500px">
      <q-card-section>
        <div class="text-h6">{{ $t('reviews.writeReview') }}</div>
      </q-card-section>

      <q-card-section>
        <q-form @submit.prevent="submitReview">
          <div class="text-center q-mb-md">
            <div class="text-body2 q-mb-sm">{{ $t('reviews.yourRating') }}</div>
            <q-rating
              v-model="form.rating"
              size="32px"
              color="warning"
              icon="star_border"
              icon-selected="star"
            />
          </div>

          <q-input
            v-model="form.title"
            :label="$t('reviews.title')"
            outlined
            class="q-mb-sm"
          />

          <q-input
            v-model="form.content"
            :label="$t('reviews.yourReview')"
            type="textarea"
            outlined
            rows="4"
            :rules="[required]"
          />
        </q-form>
      </q-card-section>

      <q-card-actions align="right">
        <q-btn flat :label="$t('common.cancel')" v-close-popup />
        <q-btn
          color="primary"
          :label="$t('common.submit')"
          :loading="submitting"
          :disable="form.rating === 0"
          @click="submitReview"
        />
      </q-card-actions>
    </q-card>
  </q-dialog>
</template>

<script setup lang="ts">
import { ref, reactive } from 'vue';
import { useQuasar } from 'quasar';
import { useI18n } from 'vue-i18n';
import { useAuth } from 'src/composables/useAuth';
import { strapiService } from 'src/services/strapi.service';

const props = defineProps<{ modelValue: boolean; productId: number }>();
const emit = defineEmits(['update:modelValue', 'submitted']);

const $q = useQuasar();
const { t } = useI18n();
const { user, session } = useAuth();

const submitting = ref(false);

const form = reactive({
  rating: 0,
  title: '',
  content: '',
});

const required = (v: string) => !!v || t('validation.required');

const submitReview = async () => {
  if (form.rating === 0) return;

  submitting.value = true;
  try {
    await strapiService.createReview({
      product: props.productId,
      customer: user.value?.id,
      rating: form.rating,
      title: form.title,
      content: form.content,
      is_verified_purchase: true,
    }, session.value?.access_token);

    $q.notify({ type: 'positive', message: t('reviews.submitted') });
    emit('submitted');

    // Reset form
    form.rating = 0;
    form.title = '';
    form.content = '';
  } catch (error) {
    $q.notify({ type: 'negative', message: t('common.error') });
  } finally {
    submitting.value = false;
  }
};
</script>
```

### Create RatingBreakdown Component
Create `frontend/src/components/products/RatingBreakdown.vue`:

```vue
<template>
  <div class="rating-breakdown">
    <div
      v-for="star in [5, 4, 3, 2, 1]"
      :key="star"
      class="row items-center q-mb-xs"
    >
      <div class="col-2 text-right q-pr-sm">
        {{ star }} <q-icon name="star" color="warning" size="14px" />
      </div>
      <div class="col">
        <q-linear-progress
          :value="getPercentage(star)"
          color="warning"
          track-color="grey-3"
          rounded
        />
      </div>
      <div class="col-2 text-left q-pl-sm text-grey-7">
        {{ getCount(star) }}
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
const props = defineProps<{ reviews: any[] }>();

const getCount = (stars: number) => {
  return props.reviews.filter(r => r.attributes.rating === stars).length;
};

const getPercentage = (stars: number) => {
  if (!props.reviews.length) return 0;
  return getCount(stars) / props.reviews.length;
};
</script>
```

### Add Review Methods to Strapi Service
Update `frontend/src/services/strapi.service.ts`:

```typescript
async getProductReviews(productId: number) {
  const response = await this.axios.get('/reviews', {
    params: {
      'filters[product][id][$eq]': productId,
      'filters[is_approved][$eq]': true,
      populate: ['customer'],
      sort: 'createdAt:desc',
    },
  });
  return response.data;
}

async createReview(data: {
  product: number;
  customer: string;
  rating: number;
  title?: string;
  content: string;
  is_verified_purchase: boolean;
}, token?: string) {
  const response = await this.axios.post('/reviews', { data }, {
    headers: token ? { Authorization: `Bearer ${token}` } : {},
  });
  return response.data;
}

async checkUserPurchased(productId: number, userId: string) {
  const response = await this.axios.get('/orders', {
    params: {
      'filters[customer][supabase_id][$eq]': userId,
      'filters[items][product][id][$eq]': productId,
      'filters[status][$eq]': 'delivered',
    },
  });
  return { purchased: response.data.data.length > 0 };
}
```

## Acceptance Criteria
- [ ] Reviews display on product page
- [ ] Rating breakdown shows correctly
- [ ] Only verified purchasers can review
- [ ] Review submission works
- [ ] Average rating calculates correctly
