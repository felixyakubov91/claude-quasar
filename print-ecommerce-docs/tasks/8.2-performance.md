# Task 8.2: Performance Optimization

## Goal
Optimize frontend performance for fast load times and good Core Web Vitals.

## Instructions

### Configure Image Lazy Loading
Create `frontend/src/components/common/LazyImage.vue`:

```vue
<template>
  <q-img
    :src="currentSrc"
    :ratio="ratio"
    :fit="fit"
    :loading="loading"
    @load="onLoad"
    v-bind="$attrs"
  >
    <template v-slot:loading>
      <div class="absolute-full flex flex-center bg-grey-2">
        <q-spinner color="primary" size="30px" />
      </div>
    </template>

    <template v-slot:error>
      <div class="absolute-full flex flex-center bg-grey-2">
        <q-icon name="broken_image" color="grey-5" size="40px" />
      </div>
    </template>

    <slot />
  </q-img>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';

const props = withDefaults(defineProps<{
  src: string;
  placeholder?: string;
  ratio?: number;
  fit?: 'cover' | 'contain' | 'fill' | 'none' | 'scale-down';
  loading?: 'eager' | 'lazy';
  cloudinaryTransform?: string;
}>(), {
  fit: 'cover',
  loading: 'lazy',
});

const isLoaded = ref(false);

const currentSrc = computed(() => {
  if (!props.src) return '';

  // Apply Cloudinary transformations if available
  if (props.src.includes('cloudinary.com') && props.cloudinaryTransform) {
    return props.src.replace('/upload/', `/upload/${props.cloudinaryTransform}/`);
  }

  return props.src;
});

const onLoad = () => {
  isLoaded.value = true;
};
</script>
```

### Configure Code Splitting
Update `frontend/quasar.config.js`:

```javascript
build: {
  vueRouterMode: 'history',

  vitePlugins: [
    ['@intlify/unplugin-vue-i18n/vite', {
      include: [path.resolve(__dirname, './src/i18n/**')],
    }],
  ],

  // Enable chunk splitting
  extendViteConf(viteConf) {
    viteConf.build = {
      ...viteConf.build,
      rollupOptions: {
        output: {
          manualChunks: {
            'vendor-vue': ['vue', 'vue-router', 'pinia'],
            'vendor-quasar': ['quasar'],
            'vendor-utils': ['date-fns', 'axios'],
            'vendor-cloudinary': ['@cloudinary/url-gen'],
          },
        },
      },
      chunkSizeWarningLimit: 500,
    };
  },
},
```

### Configure SSR Caching
Create `frontend/src-ssr/middlewares/cache.ts`:

```typescript
import { ssrMiddleware } from 'quasar/wrappers';
import NodeCache from 'node-cache';

const pageCache = new NodeCache({
  stdTTL: 300, // 5 minutes
  checkperiod: 60,
});

// Pages to cache
const cacheableRoutes = [
  '/',
  '/products',
  '/category/',
];

export default ssrMiddleware(({ app, resolve }) => {
  app.use((req, res, next) => {
    // Only cache GET requests
    if (req.method !== 'GET') {
      return next();
    }

    // Check if route is cacheable
    const isCacheable = cacheableRoutes.some(route =>
      req.url === route || req.url.startsWith(route)
    );

    if (!isCacheable) {
      return next();
    }

    // Skip cache for authenticated users
    if (req.cookies?.['sb-access-token']) {
      return next();
    }

    const cacheKey = `page:${req.url}`;
    const cached = pageCache.get(cacheKey);

    if (cached) {
      res.set('X-Cache', 'HIT');
      return res.send(cached);
    }

    // Override res.send to cache the response
    const originalSend = res.send.bind(res);
    res.send = (body: any) => {
      if (res.statusCode === 200 && typeof body === 'string') {
        pageCache.set(cacheKey, body);
        res.set('X-Cache', 'MISS');
      }
      return originalSend(body);
    };

    next();
  });
});
```

### Add Preload and Prefetch Hints
Create `frontend/src/components/common/ResourceHints.vue`:

```vue
<template>
  <teleport to="head">
    <!-- Preconnect to critical origins -->
    <link rel="preconnect" href="https://res.cloudinary.com" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="dns-prefetch" href="https://www.google-analytics.com" />

    <!-- Preload critical fonts -->
    <link
      rel="preload"
      href="/fonts/rubik-400.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />
  </teleport>
</template>
```

### Optimize Cloudinary Images
Create `frontend/src/utils/cloudinary.ts`:

```typescript
export function getOptimizedImageUrl(
  url: string,
  options: {
    width?: number;
    height?: number;
    quality?: 'auto' | 'auto:low' | 'auto:eco' | 'auto:good' | 'auto:best';
    format?: 'auto' | 'webp' | 'avif';
    crop?: 'fill' | 'fit' | 'scale' | 'thumb';
    dpr?: 'auto' | number;
  } = {}
): string {
  if (!url || !url.includes('cloudinary.com')) {
    return url;
  }

  const {
    width,
    height,
    quality = 'auto',
    format = 'auto',
    crop = 'fill',
    dpr = 'auto',
  } = options;

  const transforms: string[] = [];

  if (width) transforms.push(`w_${width}`);
  if (height) transforms.push(`h_${height}`);
  if (crop) transforms.push(`c_${crop}`);
  transforms.push(`q_${quality}`);
  transforms.push(`f_${format}`);
  if (dpr) transforms.push(`dpr_${dpr}`);

  const transformation = transforms.join(',');

  return url.replace('/upload/', `/upload/${transformation}/`);
}

// Srcset generator for responsive images
export function getResponsiveImageSrcset(
  url: string,
  widths: number[] = [320, 640, 960, 1280, 1920]
): string {
  return widths
    .map(w => `${getOptimizedImageUrl(url, { width: w })} ${w}w`)
    .join(', ');
}
```

### Add Virtual Scrolling for Large Lists
Update `frontend/src/pages/products/IndexPage.vue`:

```vue
<template>
  <q-page class="q-pa-md">
    <q-virtual-scroll
      :items="products"
      :virtual-scroll-item-size="300"
      v-slot="{ item, index }"
    >
      <ProductCard :key="item.id" :product="item" />
    </q-virtual-scroll>
  </q-page>
</template>
```

### Configure Service Worker for Caching
Update `frontend/src-pwa/custom-service-worker.ts`:

```typescript
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, StaleWhileRevalidate, NetworkFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

declare const self: ServiceWorkerGlobalScope & typeof globalThis;

// Clean old caches
cleanupOutdatedCaches();

// Precache static assets
precacheAndRoute(self.__WB_MANIFEST);

// Cache images
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Cache Cloudinary images
registerRoute(
  ({ url }) => url.hostname.includes('cloudinary.com'),
  new CacheFirst({
    cacheName: 'cloudinary-images',
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
      }),
    ],
  })
);

// Cache API responses
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/products'),
  new StaleWhileRevalidate({
    cacheName: 'api-products',
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 5 * 60, // 5 minutes
      }),
    ],
  })
);

// Network first for dynamic content
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    networkTimeoutSeconds: 10,
  })
);
```

### Add Performance Monitoring
Create `frontend/src/utils/performance.ts`:

```typescript
export function measureWebVitals() {
  if (typeof window === 'undefined') return;

  // Largest Contentful Paint
  const lcpObserver = new PerformanceObserver((list) => {
    const entries = list.getEntries();
    const lastEntry = entries[entries.length - 1];
    console.log('LCP:', lastEntry.startTime);
  });
  lcpObserver.observe({ type: 'largest-contentful-paint', buffered: true });

  // First Input Delay
  const fidObserver = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
      console.log('FID:', (entry as PerformanceEventTiming).processingStart - entry.startTime);
    }
  });
  fidObserver.observe({ type: 'first-input', buffered: true });

  // Cumulative Layout Shift
  let clsValue = 0;
  const clsObserver = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
      if (!(entry as any).hadRecentInput) {
        clsValue += (entry as any).value;
      }
    }
    console.log('CLS:', clsValue);
  });
  clsObserver.observe({ type: 'layout-shift', buffered: true });
}
```

## Acceptance Criteria
- [ ] Images lazy load correctly
- [ ] Cloudinary transformations applied
- [ ] Code splitting reduces bundle size
- [ ] SSR caching works
- [ ] Lighthouse performance score > 80
- [ ] Core Web Vitals pass
